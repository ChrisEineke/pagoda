#!/usr/bin/env node

const cli = require("command-line-args")
const fs = require("fs-extra")
const path = require("path")
const tmp = require("tmp")
const when = require("when")
const winston = require("winston")

const Pagoda = require("../src")


tmp.setGracefulCleanup()
winston.add(winston.transports.File, { filename: "pagoda.log" })
winston.remove(winston.transports.Console)

const commandOptions = cli([
    { name: "command", type: String, defaultOption: true },
], {
    stopAtFirstUnknown: true
})
const argv = commandOptions._unknown || []

const options = cli([
    { name: "manifest", type: String, defaultOption: true },
    { name: "outputDir", type: String },
    { name: "logLevel", type: String },
], { argv })

winston.level = options["logLevel"] || "info"

const outputDir = options["outputDir"] || tmp.dirSync().name

const manifestFilepath = options["manifest"] || "manifest.yaml"
const manifestDAO = new Pagoda.ManifestDAO([
    path.dirname(path.resolve(process.cwd(), manifestFilepath)),
    path.resolve(process.cwd(), "stereotypes"),
    path.resolve(__dirname, "../stereotypes"),
    process.cwd(),
])
const templateDAO = new Pagoda.TemplateDAO([
    path.dirname(path.resolve(process.cwd(), manifestFilepath)),
    path.resolve(process.cwd(), "templates"),
    path.resolve(__dirname, "../templates"),
    process.cwd(),
])
const stereotypeDAO = new Pagoda.StereotypeDAO([
    path.dirname(path.resolve(process.cwd(), manifestFilepath)),
    path.resolve(process.cwd(), "stereotypes"),
    path.resolve(__dirname, "../stereotypes"),
    process.cwd(),
])
const command = commandOptions["command"]

function generateTemplates(templates, context, outputDir) {
    return when.map(templates, template => {
        return template.generate(context).then(res => {
            return fs.writeFile(path.join(outputDir, res.id), res.contents)
        })
    })
}

when(manifestDAO.fromYamlFile(manifestFilepath)).then(manifest => {
    return manifest.applyStereotype(stereotypeDAO)
}).then(manifest => {
    if (command == "show") {
        console.log(manifestDAO.toYaml(manifest))
    }

    if (command == "compile") {
        when.try(() => {
            return fs.ensureDir(outputDir)
        }).then(() => {
            return manifestDAO.toYamlFile(manifest, path.join(outputDir, 'manifest.yaml'))
        })
    }

    if (command == "compile-requires" || command == "compile") {
        /*
         * Generate dependency checks.
         */
    }

    if (command == "compile-provides" || command == "compile") {
    }

    if (command == "compile-resources" || command == "compile") {
        when.try(() => {
            return fs.ensureDir(outputDir)
        }).then(() => {
            return when.map(manifest.resources, manifestId => {
                return manifestDAO.fromId(manifestId).then(manifest => {
                    return when.map(manifest.provides, provide => {
                        return generateTemplates(templateDAO.fromId(provide.template), {
                            id: manifest.id,
                            owner: manifest.owner,
                        }, outputDir)
                    })
                })
            })
        })
    }

    if (command == "compile-integrations" || command == "compile") {
    }

    if (command == "compile-deployments" || command == "compile") {
        when.try(() => {
            return fs.ensureDir(outputDir)
        }).then(() => {
            return when.map(manifest.deployments, deploymentId => {
                return generateTemplates(templateDAO.fromId(deploymentId), {
                    id: manifest.id,
                    owner: manifest.owner,
                }, outputDir)
            })
        })
    }
})
