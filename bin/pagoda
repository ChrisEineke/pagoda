#!/usr/bin/env node

const cli = require("command-line-args")
const fs = require("fs-extra")
const lo = require("lodash")
const path = require("path")
const tmp = require("tmp")
const winston = require("winston")

const Pagoda = require("../src")


tmp.setGracefulCleanup()
winston.add(winston.transports.File, { filename: "pagoda.log" })
winston.remove(winston.transports.Console)

main()

function main() {
    const mainCommandOptions = cli([
        { name: "command", type: String, defaultOption: true },
    ], {
        stopAtFirstUnknown: true
    })
    const argv = mainCommandOptions._unknown || []
    const command = mainCommandOptions["command"]

    switch (command) {
    case "manifest":
        handleManifestCommand(argv)
        break
    default:
        /* TODO: print help */
        break
    }
}

function handleManifestCommand(argv) {
    const subCommandOptions = cli([
        { name: "command", type: String, defaultOption: true },
    ], { stopAtFirstUnknown: true, argv })
    const nextArgv = subCommandOptions._unknown || []
    const subCommand = subCommandOptions["command"]

    switch (subCommand) {
    case "dump":
        handleManifestDumpCommand(nextArgv)
        break
    case "compile":
        handleManifestCompileCommand(nextArgv)
        break
    default:
        /* TODO: print help */
    }
}

function handleManifestDumpCommand(argv) {
    const options = cli([
        { name: "logLevel", type: String },
        { name: "outputDir", type: String },
        { name: "manifest", type: String, defaultOption: true },
    ], { argv })
    winston.level = options["logLevel"] || "info"
    const outputDir = options["outputDir"] || tmp.dirSync().name

    const manifestFilepath = options["manifest"] || "manifest.yaml"
    const manifestDAO = makeManifestDAO(manifestFilepath)
    const templateDAO = makeTemplateDAO(manifestFilepath)
    const stereotypeDAO = makeStereotypeDAO(manifestFilepath)

    try {
        (async function main() {
            const unexpandedManifest = await manifestDAO.fromYamlFile(manifestFilepath)
            const manifest = await unexpandedManifest.expand({
                stereotypeDAO: stereotypeDAO,
                manifestDAO: manifestDAO,
                templateDAO: templateDAO
            })
            console.log(manifestDAO.toYaml(manifest))
        })()
    }
    catch (e) {
        winston.error(e)
        console.error(e)
    }
}

function handleManifestCompileCommand(argv) {
    const options = cli([
        { name: "logLevel", type: String },
        { name: "outputDir", type: String },
        { name: "manifest", type: String, defaultOption: true },
    ], { argv })
    winston.level = options["logLevel"] || "info"
    const outputDir = options["outputDir"] || tmp.dirSync().name

    const manifestFilepath = options["manifest"] || "manifest.yaml"
    const manifestDAO = makeManifestDAO(manifestFilepath)
    const templateDAO = makeTemplateDAO(manifestFilepath)
    const stereotypeDAO = makeStereotypeDAO(manifestFilepath)

    try {
        (async function main() {
            const unexpandedManifest = await manifestDAO.fromYamlFile(manifestFilepath)
            const manifest = await unexpandedManifest.expand({
                stereotypeDAO: stereotypeDAO,
                manifestDAO: manifestDAO,
                templateDAO: templateDAO
            })
            await fs.ensureDir(outputDir)
            await manifestDAO.toYamlFile(manifest, path.join(outputDir, 'manifest.yaml'))
            const templates = await manifest.collectTemplates()
            lo.forEach(templates, async (val, key) => {
                await fs.writeFile(path.join(outputDir, key), val)
            })
        })()
    }
    catch (e) {
        winston.error(e)
        console.error(e)
    }
}

function makeManifestDAO(manifestFilepath) {
    const dirpaths = []
    const absManifestFilepath = path.resolve(process.cwd(), manifestFilepath)

    dirpaths.push(path.dirname(absManifestFilepath))
    for (const i of ["manifests", "resources", "integrations", "deployments"]) {
        // directories in the directory that contains the manifest
        dirpaths.push(path.resolve(path.dirname(absManifestFilepath), i))
        // directories in the current working directory
        dirpaths.push(path.resolve(process.cwd(), i))
        // the current working directory
    }
    dirpaths.push(process.cwd())
    return new Pagoda.ManifestCompiler.ManifestDAO(dirpaths)
}

function makeTemplateDAO(manifestFilepath) {
    const dirpaths = []
    const absManifestFilepath = path.resolve(process.cwd(), manifestFilepath)

    // 'templates' directory in the directory that contains the manifest
    dirpaths.push(path.resolve(path.dirname(absManifestFilepath), "templates"))
    // directory that contains the manifest
    dirpaths.push(path.dirname(absManifestFilepath))
    // 'templates' directory in the current working directory
    dirpaths.push(path.resolve(process.cwd(), "templates"))
    // the current working directory
    dirpaths.push(process.cwd())

    return new Pagoda.ManifestCompiler.TemplateDAO(dirpaths)
}

function makeStereotypeDAO(manifestFilepath) {
    const dirpaths = []
    const absManifestFilepath = path.resolve(process.cwd(), manifestFilepath)

    // 'stereotypes' directory in the directory that contains the manifest
    dirpaths.push(path.resolve(path.dirname(absManifestFilepath), "stereotypes"))
    // directory that contains the manifest
    dirpaths.push(path.dirname(absManifestFilepath))
    // 'stereotypes' directory in the current working directory
    dirpaths.push(path.resolve(process.cwd(), "stereotypes"))
    // the current working directory
    dirpaths.push(process.cwd())

    return new Pagoda.ManifestCompiler.StereotypeDAO(dirpaths)
}
